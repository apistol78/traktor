import(traktor)


-- Total amount of memory allocated by Emscripten product at runtime.
local totalMemory = 128 * 1024 * 1024


-- Tools
local tools =
{
	pipeline = "$(DEPLOY_SYSTEM_ROOT)/bin/latest/$(DEPLOY_HOST_OS)/releaseshared/Traktor.Pipeline.App",
	migrate = "$(DEPLOY_SYSTEM_ROOT)/bin/latest/$(DEPLOY_HOST_OS)/releaseshared/Traktor.Database.Migrate.App",
	remote = "$(DEPLOY_SYSTEM_ROOT)/bin/latest/$(DEPLOY_HOST_OS)/releaseshared/Traktor.Remote.Client.App"
}


function string:trim()
	return self:find'^%s*$' and '' or self:match'^%s*(.*%S)'
end


function string:starts(start)
   return string.sub(self, 1, string.len(start)) == start
end


function string:split(sep)
	local sep, fields = sep or ":", {}
	local pattern = string.format("([^%s]+)", sep)
	self:gsub(pattern, function(c) fields[#fields+1] = c end)
	return fields
end


function string:startswith(st)
	return self:sub(1, #st) == st
end


function string:endswith(send)
	return #self >= #send and self:find(send, #self - #send + 1, true) and true or false
end


-- Setup environment for emscripten; we need to ensure we're using emscripten specified in our configuration.
local function setupEmscriptenEnvironment()
	local emsdk = os:getEnvironment("DEPLOY_EMSCRIPTEN")
	if #emsdk <= 0 then
		stderr:printLn("DEPLOY_EMSCRIPTEN not set; ensure Emscripten SDK is properly installed and try again.")
		return nil
	end

	local emscripten = emsdk .. "/emscripten/1.37.36"
	local clang = emsdk .. "/clang/e1.37.36_64bit"
	local binaryen = emsdk .. "/clang/e1.37.36_64bit/binaryen"
	local java = emsdk .. "/java/8.152_64bit"
	local python = emsdk .. "/python/2.7.13.1_64bit"
	local node = emsdk .. "/node/8.9.1_64bit"

	os:setEnvironment("EMSCRIPTEN", emscripten)
	os:setEnvironment("BINARYEN_ROOT", binaryen)
	os:setEnvironment("BINARYEN", binaryen)
	os:setEnvironment("JAVA_HOME", java)

	local p = os:getEnvironment("PATH")
	os:setEnvironment(
		"PATH",
		clang .. ";" ..
		node .. "/bin;" ..
		python .. "/python-2.7.13.amd64;" ..
		java .. "/bin;" ..
		emsdk .. ";" ..
		emscripten .. ";" ..
		p
	)

	return emscripten
end


function build(args)
	stdout:printLn("Building asset(s)...")
	local cmdline = tools.pipeline .. " -p -s=Pipeline"
	for i = 1, args:size() - 1 do
		cmdline = cmdline .. " " .. args:get(i)
	end
	return run:execute(cmdline)
end


function deploy(args)
	stdout:printLn("Deploying Emscripten...")

	local host = os:getEnvironment("DEPLOY_HOST_OS")
	local debug = (os:getEnvironment("DEPLOY_DEBUG") ~= "")

	local emscripten = setupEmscriptenEnvironment()
	if emscripten == nil then return 1 end

	-- Get toolchain binaries.
	local emcc = emscripten .. "/emcc" 
	if #emcc <= 0 then
		stderr:printLn("Unable to determine toolchain binaries; ensure Emscripten SDK is properly installed and try again.")
		return 1
	end

	-- As toolchain binaries on Windows are actually bat-file wrappers we need to append suffix.
	if host == "win32" or host == "win64" then
		emcc = emcc .. ".bat"
	end

	-- Get library paths.
	local libraryPaths = ""
	local paths = ""
	if not debug then paths = os:getEnvironment("DEPLOY_STATIC_PATH_RELEASE"):split("\n") else paths = os:getEnvironment("DEPLOY_STATIC_PATH_DEBUG"):split("\n") end
	 for _, p in pairs(paths) do
		libraryPaths = libraryPaths .. " -L " .. Path(p).pathName .. ""
	end

	-- Collect libraries to link.
	local libraries = ""
	local files = os:getEnvironment("DEPLOY_STATIC"):split("\n")
	for _, f in ipairs(files) do
		if f:endswith(".a") then
			f = f:sub(4)
			f = f:sub(1, #f - 2)
			libraries = libraries .. " -l" .. f		
		elseif f:endswith(".bc") or f:endswith(".o") then
			libraries = libraries .. " " .. f
		else
			stderr:printLn("Unknown deploy file \"" .. f .. "\"")
		end
	end

	-- Create the module initialization file.
	stdout:printLn("Generating Linkage.cpp...")
	if run:run("$(DEPLOY_SYSTEM_ROOT)/resources/runtime/deploy/emscripten/Linkage.cpp.template", "Linkage.cpp") ~= 0 then
		stderr:printLn("Failed to generate Linkage.cpp")
		return 1
	end	

	-- Compile linkage file.
	stdout:printLn("Compiling Linkage.cpp...")
	local cmd = "\"" .. emcc .. "\" -s WASM=1 Linkage.cpp -o Linkage.o"
	local result = run:execute(cmd) --, nil)
	if result ~= 0 then
		stderr:printLn("Unable to compile file.")
		return 1
	end

	-- Build linker command line.
	local cmd = "\"" .. emcc .. "\" "
	cmd = cmd .. " -s WASM=1"
	cmd = cmd .. " -s BINARYEN_TRAP_MODE='clamp'"
	-- cmd = cmd .. " -s ERROR_ON_UNDEFINED_SYMBOLS=0"
	cmd = cmd .. " -s USE_PTHREADS=0"
	cmd = cmd .. " -s TOTAL_MEMORY=" .. totalMemory
	-- cmd = cmd .. " -Wl,-s,ERROR_ON_UNDEFINED_SYMBOLS=0"
	-- cmd = cmd .. " -g"
	cmd = cmd .. " -O2"
	cmd = cmd .. " Linkage.o"
	cmd = cmd .. libraryPaths
	cmd = cmd .. libraries
	cmd = cmd .. libraries
	cmd = cmd .. " -o $(DEPLOY_EXECUTABLE).html --preload-file Application.config"

	-- Link files into an executable product.
	local result = run:execute(cmd, nil)
	if result ~= 0 then
		stderr:printLn("Unable to build executable product.")
		stderr:printLn(cmd)
		return 1
	end

	-- Remove intermediate files.
	run:rm("Linkage.*")

	-- Create html loader.
	if run:run("$(DEPLOY_SYSTEM_ROOT)/resources/runtime/deploy/emscripten/Index.html.template", os:getEnvironment("DEPLOY_EXECUTABLE") .. ".html") ~= 0 then
		stderr:printLn("Failed to generate HTML loader.")
		return 1
	end

	return 0
end


function launch(args)
	return 0
end


function migrate(args)
	stdout:printLn("Migrating Emscripten...")

	local result = run:execute(tools.migrate .. " -p -s=Migrate")
	if result ~= 0 then
		stderr:printLn("Unable to migrate content.")
		return 1
	end

	stdout:printLn("Deploying Emscripten...")

	local host = os:getEnvironment("DEPLOY_HOST_OS")
	local debug = (os:getEnvironment("DEPLOY_DEBUG") ~= "")

	local emscripten = setupEmscriptenEnvironment()
	if emscripten == nil then return 1 end

	-- Get toolchain binaries.
	local emcc = emscripten .. "/emcc" 
	if #emcc <= 0 then
		stderr:printLn("Unable to determine toolchain binaries; ensure Emscripten SDK is properly installed and try again.")
		return 1
	end

	-- As toolchain binaries on Windows are actually bat-file wrappers we need to append suffix.
	if host == "win32" or host == "win64" then
		emcc = emcc .. ".bat"
	end

	-- Get library paths.
	local libraryPaths = ""
	local paths = ""
	if not debug then paths = os:getEnvironment("DEPLOY_STATIC_PATH_RELEASE"):split("\n") else paths = os:getEnvironment("DEPLOY_STATIC_PATH_DEBUG"):split("\n") end
	 for _, p in pairs(paths) do
		libraryPaths = libraryPaths .. " -L " .. Path(p).pathName .. ""
	end

	-- Collect libraries to link.
	local libraries = ""
	local files = os:getEnvironment("DEPLOY_STATIC"):split("\n")
	for _, f in ipairs(files) do
		if f:endswith(".a") then
			f = f:sub(4)
			f = f:sub(1, #f - 2)
			libraries = libraries .. " -l" .. f		
		elseif f:endswith(".bc") or f:endswith(".o") then
			libraries = libraries .. " " .. f
		else
			stderr:printLn("Unknown deploy file \"" .. f .. "\"")
		end
	end

	-- Create the module initialization file.
	stdout:printLn("Generating Linkage.cpp...")
	if run:run("$(DEPLOY_SYSTEM_ROOT)/resources/runtime/deploy/emscripten/Linkage.cpp.template", "Linkage.cpp") ~= 0 then
		stderr:printLn("Failed to generate Linkage.cpp")
		return 1
	end	

	-- Compile linkage file.
	stdout:printLn("Compiling Linkage.cpp...")
	local cmd = "\"" .. emcc .. "\" -s WASM=1 Linkage.cpp -o Linkage.o"
	local result = run:execute(cmd) --, nil)
	if result ~= 0 then
		stderr:printLn("Unable to compile file.")
		return 1
	end

	-- Build linker command line.
	local cmd = "\"" .. emcc .. "\" "
	cmd = cmd .. " -s WASM=1"
	cmd = cmd .. " -s BINARYEN_TRAP_MODE='clamp'"
	-- cmd = cmd .. " -s ERROR_ON_UNDEFINED_SYMBOLS=0"
	cmd = cmd .. " -s USE_PTHREADS=0"
	cmd = cmd .. " -s TOTAL_MEMORY=" .. totalMemory
	-- cmd = cmd .. " -Wl,-s,ERROR_ON_UNDEFINED_SYMBOLS=0"
	-- cmd = cmd .. " -g"
	cmd = cmd .. " -O2"
	cmd = cmd .. " Linkage.o"
	cmd = cmd .. libraryPaths
	cmd = cmd .. libraries
	cmd = cmd .. libraries
	cmd = cmd .. " -o $(DEPLOY_EXECUTABLE).html --preload-file Application.config --preload-file Content.compact"

	-- Link files into an executable product.
	local result = run:execute(cmd, nil)
	if result ~= 0 then
		stderr:printLn("Unable to build executable product.")
		stderr:printLn(cmd)
		return 1
	end

	-- Remove intermediate files.
	run:rm("Linkage.*")

	-- Create html loader.
	if run:run("$(DEPLOY_SYSTEM_ROOT)/resources/runtime/deploy/emscripten/Index.html.template", os:getEnvironment("DEPLOY_EXECUTABLE") .. ".html") ~= 0 then
		stderr:printLn("Failed to generate HTML loader.")
		return 1
	end

	stdout:printLn("Done")
	return 0
end


function main(args)
	local action = args:get(0)
	if action == "build" then
		return build(args)
	elseif action == "deploy" then
		return deploy(args)
	elseif action == "launch" then
		return launch(args)
	elseif action == "migrate" then
		return migrate(args)
	end
	return 1
end
